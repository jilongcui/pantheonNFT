// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../ERC721.sol";
import "../extensions/ERC721Enumerable.sol";
import "../extensions/ERC721Burnable.sol";
import "../extensions/ERC721Pausable.sol";
import "../../../access/AccessControlEnumerable.sol";
import "../../../utils/Context.sol";
import "../../../utils/Counters.sol";

/**
 * @dev {ERC721} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 */
contract ERC721Card is
    Context,
    AccessControlEnumerable,
    ERC721Enumerable,
    ERC721Burnable,
    ERC721Pausable
{
    using Counters for Counters.Counter;

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    Counters.Counter private _tokenIdTracker;

    string private _baseTokenURI;

    struct CardInfo {
        uint16 total;
        uint16 current;
        uint16 power;
    }
    mapping(uint256 => uint8) nftCategory;
    mapping(uint256 => uint8) nftLevel;
    mapping(uint256 => uint16) nftPower;
    mapping(uint256 => uint256) nftIndex;
    // CardInfo struct as [category][level][cardInfo]
    mapping(uint8 => mapping(uint8 => CardInfo)) cardInfo;

    event MintWithLevel(
        address indexed from,
        address indexed to,
        uint16 category,
        uint32 serialNo,
        uint16 level,
        uint256 timestamp
    );

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        address adminAddress,
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;

        _setupRole(DEFAULT_ADMIN_ROLE, adminAddress);
        _setupRole(PAUSER_ROLE, adminAddress);
        _setupRole(MINTER_ROLE, adminAddress);
        _setupRole(MINTER_ROLE, _msgSender());
        setCardInfo();
    }

    function setCardInfo() internal {
        cardInfo[1][4] = CardInfo({total: 10, power: 450, current: 0});
        cardInfo[1][3] = CardInfo({total: 100, power: 200, current: 0});
        cardInfo[1][2] = CardInfo({total: 150, power: 150, current: 0});
        cardInfo[1][1] = CardInfo({total: 200, power: 120, current: 0});
        cardInfo[1][0] = CardInfo({total: 540, power: 100, current: 0});

        cardInfo[2][4] = CardInfo({total: 10, power: 450, current: 0});
        cardInfo[2][3] = CardInfo({total: 100, power: 200, current: 0});
        cardInfo[2][2] = CardInfo({total: 150, power: 150, current: 0});
        cardInfo[2][1] = CardInfo({total: 200, power: 120, current: 0});
        cardInfo[2][0] = CardInfo({total: 540, power: 100, current: 0});

        cardInfo[3][4] = CardInfo({total: 10, power: 450, current: 0});
        cardInfo[3][3] = CardInfo({total: 0, power: 200, current: 0});
        cardInfo[3][2] = CardInfo({total: 0, power: 150, current: 0});
        cardInfo[3][1] = CardInfo({total: 0, power: 120, current: 0});
        cardInfo[3][0] = CardInfo({total: 990, power: 100, current: 0});
    }

    function setCardTotal(
        uint8 _category,
        uint8 _level,
        uint16 _total
    ) public returns (bool) {
        CardInfo storage card = cardInfo[_category][_level];
        card.total = _total;
        return true;
    }

    function setCardPower(
        uint8 _category,
        uint8 _level,
        uint16 _power
    ) public returns (bool) {
        CardInfo storage card = cardInfo[_category][_level];
        card.power = _power;
        return true;
    }

    function setBaseURI(string memory _tokenURI) public returns (bool) {
        hasRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _baseTokenURI = _tokenURI;
        return true;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function levelOf(uint256 id) external view returns (uint8 level) {
        return nftLevel[id];
    }

    function powerOf(uint256 id) external view returns (uint16 power) {
        return nftPower[id];
    }

    function categoryOf(uint256 id) external view returns (uint8 category) {
        return nftCategory[id];
    }

    function nftIndexOf(uint256 id) external view returns (uint256 index) {
        return nftIndex[id];
    }

    function cardCategory(uint8 _category, uint8 _level)
        external
        view
        returns (
            uint16 total,
            uint16 current,
            uint16 power
        )
    {
        CardInfo memory card = cardInfo[_category][_level];
        return (card.total, card.current, card.power);
    }

    function getCard(uint256 id)
        external
        view
        returns (
            uint16 category,
            uint16 level,
            uint16 power,
            address owner
        )
    {
        CardInfo memory card = cardInfo[nftCategory[id]][nftLevel[id]];
        return (nftCategory[id], nftLevel[id], card.power, ownerOf(id));
    }

    // Get a random 100
    function random() private view returns (uint16) {
        return
            uint16(
                uint256(
                    keccak256(
                        abi.encodePacked(block.timestamp, block.difficulty)
                    )
                ) % 10000
            );
    }

    // Get a SerialNo
    function getSerialNo(uint8 category, uint16 current)
        private
        view
        returns (uint32)
    {
        return
            uint32(
                uint256(keccak256(abi.encodePacked(category, current))) %
                    1000000000
            );
    }

    function getAvailableCard(uint8 _category)
        private
        view
        returns (uint8, uint16)
    {
        uint16 rand = random();
        uint8 level = 0;
        if (rand > (2000 + 1500 + 1000 + 100)) {
            level = 0;
        } else if (rand > (1500 + 1000 + 100)) {
            level = 1;
        } else if (rand > (1000 + 100)) {
            level = 2;
        } else if (rand > 100) {
            level = 3;
        } else {
            level = 4;
        }
        // look up downward
        for (int8 i = int8(level); i >= 0; i--) {
            uint8 l = uint8(i);
            CardInfo memory card = cardInfo[_category][l];
            if (card.current + 1 <= card.total) {
                return (l, card.current + 1);
            }
        }
        // look up upward
        for (int8 i = int8(level + 1); i <= 4; i++) {
            uint8 l = uint8(i);
            CardInfo memory card = cardInfo[_category][l];
            if (card.current + 1 <= card.total) {
                return (l, card.current + 1);
            }
        }
        revert("No available card");
    }

    function mintCard(
        uint8 category,
        uint32 serialNo,
        address to
    ) public returns (uint8, uint256) {
        (uint8 level, uint16 current) = getAvailableCard(category);
        CardInfo storage card = cardInfo[category][level];
        require(card.current + 1 < card.total, "This level card is mint out");
        require(nftIndex[serialNo] == 0, "This serialNo is used.");
        card.current += 1;
        uint256 idx = mint(to, serialNo);
        nftLevel[serialNo] = level;
        nftPower[serialNo] = card.power;
        nftCategory[serialNo] = category;
        nftIndex[serialNo] = idx;
        emit MintWithLevel(
            msg.sender,
            to,
            category,
            serialNo,
            level,
            block.timestamp
        );

        return (level, card.power);
    }

    function mintWithLevel(
        uint8 _category,
        uint32 _serialNo,
        uint8 _level,
        address to
    ) public returns (bool) {
        require(_level < 5, "Level exceed the limit of 5");
        CardInfo storage level = cardInfo[_category][_level];
        if (level.current + 1 < level.total) {
            level.current += 1;
            uint256 idx = mint(to, _serialNo);
            nftLevel[_serialNo] = _level;
            nftPower[_serialNo] = level.power;
            nftCategory[_serialNo] = _category;
            nftIndex[_serialNo] = idx;
            emit MintWithLevel(
                msg.sender,
                to,
                _category,
                _serialNo,
                _level,
                block.timestamp
            );
        }

        return true;
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(address to, uint32 serialNo) private returns (uint256) {
        require(
            hasRole(MINTER_ROLE, _msgSender()),
            "ERC721PresetMinterPauserAutoId: must have minter role to mint"
        );

        // We cannot just use balanceOf to create the new tokenId because tokens
        // can be burned (destroyed), so we need a separate counter.
        uint256 current = _tokenIdTracker.current();
        _mint(to, uint256(serialNo));
        _tokenIdTracker.increment();
        return current;
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual {
        require(
            hasRole(PAUSER_ROLE, _msgSender()),
            "ERC721PresetMinterPauserAutoId: must have pauser role to pause"
        );
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual {
        require(
            hasRole(PAUSER_ROLE, _msgSender()),
            "ERC721PresetMinterPauserAutoId: must have pauser role to unpause"
        );
        _unpause();
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(AccessControlEnumerable, ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
